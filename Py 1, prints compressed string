import heapq
from collections import Counter

class HuffmanNode:
    def __init__(self, chars, freq):
        self.chars = chars
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(data):
    frequency = Counter(data)
    priority_queue = [HuffmanNode([char], freq) for char, freq in frequency.items()]
    heapq.heapify(priority_queue)

    while len(priority_queue) > 1:
        left = heapq.heappop(priority_queue)
        right = heapq.heappop(priority_queue)

        internal_node = HuffmanNode(left.chars + right.chars, left.freq + right.freq)
        internal_node.left = left
        internal_node.right = right

        heapq.heappush(priority_queue, internal_node)

    return priority_queue[0]

def generate_huffman_codes(node, current_code="", code_dict=None):
    if code_dict is None:
        code_dict = {}

    if node is not None:
        if len(node.chars) == 1:
            code_dict[node.chars[0]] = current_code
        generate_huffman_codes(node.left, current_code + "0", code_dict)
        generate_huffman_codes(node.right, current_code + "1", code_dict)

    return code_dict

def build_huffman_table(data):
    root = build_huffman_tree(data)
    huffman_codes = generate_huffman_codes(root)

    final_codes = {}
    unique_chars = list(set(data))

    for char in unique_chars:
        if char in huffman_codes:
            final_codes[char] = huffman_codes[char]

    return final_codes

if __name__ == "__main__":
    input_data = input("Enter the message you want to compress: ")
    
    huffman_table = build_huffman_table(input_data)
    
    compressed_output = ""
    for char in input_data:
        compressed_output += huffman_table[char]

    print("\nHuffman Codes:")
    for chars, code in huffman_table.items():
        print(f"{chars}: {code}")

    print("\nCompressed Output:")
    print(compressed_output)
